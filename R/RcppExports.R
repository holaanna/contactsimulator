# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Functional form of the intensity (beta) as a function of t.
#'
#'\code{func_time_beta} returns the value of the intensity as a function of t.
#'
#' @param t,t_intervention  Time of the contact and the introduction of the control respectively espressed in days.
#' @param sum_beta,epsilon   Total risk from infected premisses and the primary infection rate respectively.
#' @param omega             Introduses the effect of seasonality in the infection rate.
#'
#' @details The particular case of transmission rate used here is given by \deqn{\beta(t)= n(t)\beta + \epsilon)cos^2(\omega t) if t<t_interventioin}
#'          where n(t) is the size of potential sources.
#'
#' @return It returns the rate of infection in the non-homogeneous poisson process.
#'
#' @examples
#' func_time_beta(20,50,0.08,0.2,0.3)
#' @export
func_time_beta <- function(t, t_intervention, sum_beta, epsilon, omega) {
    .Call('_contactsimulator_func_time_beta', PACKAGE = 'contactsimulator', t, t_intervention, sum_beta, epsilon, omega)
}

#' Simulation of the time of the next event of a non-homogeneous oisson process .
#'
#'\code{simulate_NHPP_next_event} computes the next-event time given the current state at t.
#'
#' @param t_now,t_intervention,t_max  current time, the introduction of the control and the final observation time (usually fixed)
#'        respectively espressed in days.
#' @param sum_beta,epsilon total risk from infected premisses and the primary infection rate respectively.
#' @param omega, introduses the effect of seasonality in the infection rate.
#'
#' @return It returns the next-event time in the non-homogeneous poisson process.
#'
#' @examples
#'simulate_NHPP_next_event(2,50,0.08,0.2,0.3,300)
#' @export
simulate_NHPP_next_event <- function(t_now, t_intervention, sum_beta, epsilon, omega, t_max) {
    .Call('_contactsimulator_simulate_NHPP_next_event', PACKAGE = 'contactsimulator', t_now, t_intervention, sum_beta, epsilon, omega, t_max)
}

#' Generates a set of intersection points between the cirlce and the grid lines.
#'
#'\code{circle_line_intersections} computes the intersections points of a given circle with the grid lines along with
#' the angle formed with the x-axis.
#'
#' @param circle_x,circle_y The the euclidean coordinates of the center of the circle.
#'
#' @param r The radius of the given circle.
#' @param n_line The number of grid lines.
#' @param grid_lines A 6 columns data frame with columns names as coor_x_1, coor_y_1, coor_x_2, coor_y_2, orient_line.
#' \describe{
#'     \item{coor_x_1, coor_y_1}{Coordinates of the left end point of the grid line }
#'     \item{coor_x_2, coor_y_2}{Coordinates of the right end point of the grid line }
#'     \item{orient_line}{Line orientation}
#'     \enumerate{
#'        \item indicates horizontal orientation
#'        \item indicates vetical orientation
#'     }
#'     \item{k_line}{Line numbering: bottom to top, then left to right}
#' }
#'
#' @return It returns a three columns data frame containing x-coordinate, y-coordanate of the intersection of the circle with the
#' grid, and the value of the angle betweem the x-axis and the line joining the center of the circle to the corresponding
#' intersection point.
#'
#' @examples
#' data(grid_line)
#' attach(grid_line)
#' circle_line_intersections(2022230,-3123109,10000,39,grid_line)
#' detach(grid_line)
#' @export
circle_line_intersections <- function(circle_x, circle_y, r, n_line, grid_lines) {
    .Call('_contactsimulator_circle_line_intersections', PACKAGE = 'contactsimulator', circle_x, circle_y, r, n_line, grid_lines)
}

#' Generates a set of segments (with length, density, and absolute angle) corresponding to a set of intersection points.
#'
#'\code{func_arcs_attributes} computes the intersectioins points of a given circle with the grid lines along with
#' the angle formed with the x-axis.
#'
#' @param set_points A data frame of intersection points between the cirlce and the grid lines.
#' @seealso{\code{\link{circle_line_intersections}}}
#' @param pop_grid  Population density of the grid a case resides. This is filled from bottom to top, then left to right.
#' @param r The travelling distance of the inoculum.
#' @param x_min,y_min  x/y min of the left 2 corners of the box.
#' @param n_row_grid,n_col_grid Number of rors and columns of the grid.
#' @param grid_size Grid resolution
#' //@inheritParams circle_line_intersections
#'
#' @return It returns a five columns data frame containing:
#'        \describe{
#'          \item{len_arc}{Length of the subtending arc delimited by the intersection points of the circle with center \code{circle_x} and \code{circle_y} with a grid}
#'          \item{dens}{Density of the grid where the new infection premisse resides}
#'          \item{theta}{Angle (between the source and the intersection points) specifying the direction of the inoculum}
#'        }
#'
#' @examples
#' data(bbtv)
#'   attach(bbtv)
#'   Dat<- bbtv[,c(2:6,8,10)]     # Coonsidering the essential part of the data
#'   Dat1<-subset(Dat,Dat$latitude> -27.3 & Dat$processedbananas%in%c("P&I","P", "NI") )  # data up in queensland (noth of brisbane)
#'   Dat1$treatmentdate[is.na(Dat1$treatmentdate)]<- Dat1$date[is.na(Dat1$treatmentdate)] # When NA, consider removal date as
#'   Dat1$detection<-as.numeric(difftime(as.Date(Dat1$date), as.Date("2011/01/01"), unit="days")) + runif(1)
#'   Dat1$removal<-as.numeric(difftime(as.Date(Dat1$treatmentdate), as.Date("2011/01/01"), unit="days"))
#'   Datt<-Dat1[,c(3,4,7,8,2)]
#' Datt$detection=Datt$detection + runif(nrow(Datt))
#'   Datt=Datt[with(Datt,order(Datt$detection)),]
#'
#' # Australian reference system
#' sp::coordinates(Datt) <- c("longitude", "latitude")
#'   sp::proj4string(Datt) <- sp::CRS("+init=epsg:4326")
#'   australianCRS <- sp::CRS("+init=epsg:3577")
#'
#'   pointsinaustraliangrid = sp::spTransform(Datt,australianCRS)
#'
#' #Raster
#'   rast <- raster::raster()
#'     raster::extent(rast) <- raster::extent(pointsinaustraliangrid) # Set same extent
#'
#'     raster::res(rast)=5000 #Set resolution
#'
#' # And then ... rasterize it! This creates a grid version
#' # of your points using the cells of rast,
#'
#'     rast2 <- raster::rasterize(pointsinaustraliangrid, rast, 1, fun=sum)
#'
#' # Extract infos on the grid
#'
#'
#'       n_row_grid=nrow_grid=raster::nrow(rast)
#'         n_col_grid=ncol_grid=raster::ncol(rast)
#'         grid_size=raster::res(rast)[1]     # Resolution
#'
#'         n_line=(nrow_grid+1) + (ncol_grid +1)  # Number of grid  lines
#'
#'         x_min=raster::xmin(rast)  # min max of the bounding box
#'         x_max=raster::xmax(rast)
#'
#'         y_min=raster::ymin(rast)
#'         y_max=raster::ymax(rast)
#'
#'         da=as.data.frame(pointsinaustraliangrid)
#'
#'         pop_per_grid=raster::values(rast2)
#'         pop_per_grid[is.na(pop_per_grid)]=0
#'       mat=matrix(pop_per_grid,nrow = nrow_grid, byrow = TRUE )
#'         pop_grid=apply(mat,2,rev)     # population per grid
#'
#' # Structure of the grid
#'         x=seq(x_min,x_max,grid_size)
#'           y=seq(y_min,y_max,grid_size)
#'
#'           grid_lines=array(0,c(n_line,6))
#'           for(i in 1:n_line){
#'             if(i<=(nrow_grid +1)){
#'               grid_lines[i,]=c(i,1,x[1],y[i],x[length(x)],y[i])
#'             }
#'             else{
#'               grid_lines[i,]=c(i,2,x[i-length(y)],y[1],x[i-length(y)],y[length(y)])
#'             }
#'           }
#'
#'           grid_lines=as.data.frame(grid_lines)
#'             colnames(grid_lines)<- c("indx","orient_line","coor_x_1","coor_y_1","coor_x_2","coor_y_2")
#'             circle_x=2022230
#'           circle_y=-3123109
#'           r=10000
#'
#'           set_points=circle_line_intersections(2022230,-3123109,10000,39,grid_lines)
#'             func_arcs_attributes(set_points, pop_grid, r, x_min, y_min, grid_size, n_row_grid, n_col_grid);
#'         detach(bbtv)
#'
#' @export
func_arcs_attributes <- function(set_points, pop_grid, r, x_min, y_min, grid_size, n_row_grid, n_col_grid) {
    .Call('_contactsimulator_func_arcs_attributes', PACKAGE = 'contactsimulator', set_points, pop_grid, r, x_min, y_min, grid_size, n_row_grid, n_col_grid)
}

#' @export
f <- function(x0, E, A) {
    .Call('_contactsimulator_f', PACKAGE = 'contactsimulator', x0, E, A)
}

#' @export
BTFinv1 <- function(E, A, t0) {
    .Call('_contactsimulator_BTFinv1', PACKAGE = 'contactsimulator', E, A, t0)
}

#' Sample the latent period corresponding to each specified model.
#'
#'\code{E_to_I} Geratee a random draw from the distribution specified for the latent period.
#'
#' @param EI_model A given integer characterising the type pf distribution for the latent period.
#' \enumerate{
#'          \item Cyclic distribution using the LER (leaf emergence rate) derived by R Allen \url{http://www.publish.csiro.au/ar/pdf/ar9780535}:
#'          \deqn{\frac{dL}{dt}=0.056cos(t-15) + 0.062}
#'          \item Gamma distribution with given rate and shape parameters: \code{\link{rgamma}}
#'          \item Expoential distribution with given rate: \code{\link{rexp}}, the default.
#'
#'        }
#' @param E The time at which the contact occurs, or strictly speaking the exposure time.
#' @param mu_lat The mean latent period.
#' @param var_lat The variance of the latent period for the gamma distribution.
#'
#' @return It returns a random draw from the latent period given the time of exposure.
#'
#' @examples
#' E_to_I(1,-20,30,10)
#' E_to_I(2,-20,30,10)
#' E_to_I(3,-20,30,10)
#' @export
E_to_I <- function(EI_model, E, mu_lat, var_lat) {
    .Call('_contactsimulator_E_to_I', PACKAGE = 'contactsimulator', EI_model, E, mu_lat, var_lat)
}

beta_by_age <- function(age, beta_by_age_vector) {
    .Call('_contactsimulator_beta_by_age', PACKAGE = 'contactsimulator', age, beta_by_age_vector)
}

