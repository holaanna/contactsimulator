% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{func_arcs_attributes}
\alias{func_arcs_attributes}
\title{Generates a set of segments (with length, density, and absolute angle) corresponding to a set of intersection points.}
\usage{
func_arcs_attributes(set_points, pop_grid, r, x_min, y_min, grid_size,
  n_row_grid, n_col_grid)
}
\arguments{
\item{set_points}{A data frame of intersection points between the cirlce and the grid lines.}

\item{pop_grid}{Population density of the grid a case resides. This is filled from bottom to top, then left to right.}

\item{r}{The travelling distance of the inoculum.}

\item{x_min, y_min}{x/y min of the left 2 corners of the box.}

\item{grid_size}{Grid resolution
//@inheritParams circle_line_intersections}

\item{n_row_grid, n_col_grid}{Number of rors and columns of the grid.}
}
\value{
It returns a five columns data frame containing:
       \describe{
         \item{len_arc}{Length of the subtending arc delimited by the intersection points of the circle with center \code{circle_x} and \code{circle_y} with a grid}
         \item{dens}{Density of the grid where the new infection premisse resides}
         \item{theta}{Angle (between the source and the intersection points) specifying the direction of the inoculum}
       }
}
\description{
\code{func_arcs_attributes} computes the intersectioins points of a given circle with the grid lines along with
the angle formed with the x-axis.
}
\examples{
data(bbtv)
  attach(bbtv)
  Dat<- bbtv[,c(2:6,8,10)]     # Coonsidering the essential part of the data
  Dat1<-subset(Dat,Dat$latitude> -27.3 & Dat$processedbananas\%in\%c("P&I","P", "NI") )  # data up in queensland (noth of brisbane)
  Dat1$treatmentdate[is.na(Dat1$treatmentdate)]<- Dat1$date[is.na(Dat1$treatmentdate)] # When NA, consider removal date as
  Dat1$detection<-as.numeric(difftime(as.Date(Dat1$date), as.Date("2011/01/01"), unit="days")) + runif(1)
  Dat1$removal<-as.numeric(difftime(as.Date(Dat1$treatmentdate), as.Date("2011/01/01"), unit="days"))
  Datt<-Dat1[,c(3,4,7,8,2)]
Datt$detection=Datt$detection + runif(nrow(Datt))
  Datt=Datt[with(Datt,order(Datt$detection)),]

# Australian reference system
sp::coordinates(Datt) <- c("longitude", "latitude")
  sp::proj4string(Datt) <- sp::CRS("+init=epsg:4326")
  australianCRS <- sp::CRS("+init=epsg:3577")

  pointsinaustraliangrid = sp::spTransform(Datt,australianCRS)

#Raster
  rast <- raster::raster()
    raster::extent(rast) <- raster::extent(pointsinaustraliangrid) # Set same extent

    raster::res(rast)=5000 #Set resolution

# And then ... rasterize it! This creates a grid version
# of your points using the cells of rast,

    rast2 <- raster::rasterize(pointsinaustraliangrid, rast, 1, fun=sum)

# Extract infos on the grid


      n_row_grid=nrow_grid=raster::nrow(rast)
        n_col_grid=ncol_grid=raster::ncol(rast)
        grid_size=raster::res(rast)[1]     # Resolution

        n_line=(nrow_grid+1) + (ncol_grid +1)  # Number of grid  lines

        x_min=raster::xmin(rast)  # min max of the bounding box
        x_max=raster::xmax(rast)

        y_min=raster::ymin(rast)
        y_max=raster::ymax(rast)

        da=as.data.frame(pointsinaustraliangrid)

        pop_per_grid=raster::values(rast2)
        pop_per_grid[is.na(pop_per_grid)]=0
      mat=matrix(pop_per_grid,nrow = nrow_grid, byrow = TRUE )
        pop_grid=apply(mat,2,rev)     # population per grid

# Structure of the grid
        x=seq(x_min,x_max,grid_size)
          y=seq(y_min,y_max,grid_size)

          grid_lines=array(0,c(n_line,6))
          for(i in 1:n_line){
            if(i<=(nrow_grid +1)){
              grid_lines[i,]=c(i,1,x[1],y[i],x[length(x)],y[i])
            }
            else{
              grid_lines[i,]=c(i,2,x[i-length(y)],y[1],x[i-length(y)],y[length(y)])
            }
          }

          grid_lines=as.data.frame(grid_lines)
            colnames(grid_lines)<- c("indx","orient_line","coor_x_1","coor_y_1","coor_x_2","coor_y_2")
            circle_x=2022230
          circle_y=-3123109
          r=10000

          set_points=circle_line_intersections(2022230,-3123109,10000,39,grid_lines)
            func_arcs_attributes(set_points, pop_grid, r, x_min, y_min, grid_size, n_row_grid, n_col_grid);
        detach(bbtv)

}
\seealso{
{\code{\link{circle_line_intersections}}}
}
